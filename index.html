<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Game Center</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --menu-bg: #16213e;
            --accent: #e94560;
            --text: #ecf0f1;
            /* Connect 4 Colors */
            --c4-board: #0f3460;
            --c4-board-shadow: #0a1f38;
        }
        body {
            font-family: 'Segoe UI', sans-serif; background-color: var(--bg-color); color: var(--text);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; margin: 0; user-select: none; overflow: hidden;
        }
        h1 { margin: 0 0 20px 0; font-weight: 800; letter-spacing: 2px; text-shadow: 0 0 10px rgba(233,69,96,0.5); }

        /* メニュー画面 */
        #menu-screen { display: none; flex-direction: column; gap: 20px; text-align: center; z-index: 10; }
        .game-btn {
            padding: 20px 50px; font-size: 1.5rem; border: none; border-radius: 12px;
            cursor: pointer; background: linear-gradient(135deg, #e94560, #c0392b); color: white; font-weight: bold;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3); transition: transform 0.2s, box-shadow 0.2s;
            position: relative; overflow: hidden;
        }
        .game-btn::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(255,255,255,0.2), transparent);
        }
        .game-btn:hover { transform: translateY(-3px); box-shadow: 0 15px 30px rgba(233,69,96,0.4); }
        .game-btn:active { transform: translateY(2px); box-shadow: 0 5px 10px rgba(0,0,0,0.2); }
        .waiting-text { font-size: 0.9rem; opacity: 0.7; margin-top: 10px; }

        /* ゲーム画面 */
        #game-screen { display: none; flex-direction: column; align-items: center; width: 100%; }
        #status-card {
            background: rgba(255,255,255,0.05); padding: 10px 40px; border-radius: 50px;
            margin-bottom: 25px; backdrop-filter: blur(10px); display: flex; align-items: center; gap: 15px;
            border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        #turn-indicator { width: 20px; height: 20px; border-radius: 50%; box-shadow: 0 0 10px currentColor; transition: background-color 0.3s; }
        #status-text { font-size: 1.2rem; font-weight: 600; letter-spacing: 1px; }

        /* 盤面コンテナ */
        #board-frame {
            padding: 15px; background-color: #34495e; border-radius: 15px;
            box-shadow: 0 30px 60px rgba(0,0,0,0.6), inset 0 2px 2px rgba(255,255,255,0.1);
            position: relative; transition: all 0.5s;
        }

        #board { display: grid; gap: 6px; position: relative; }

        /* セル共通 */
        .cell {
            width: 50px; height: 50px; background-color: rgba(0,0,0,0.2); border-radius: 4px;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.3); position: relative; z-index: 2;
        }

        /* 石（共通） */
        .disc {
            width: 40px; height: 40px; border-radius: 50%; display: block;
            box-shadow: inset -3px -3px 5px rgba(0,0,0,0.3), inset 2px 2px 5px rgba(255,255,255,0.3), 3px 3px 5px rgba(0,0,0,0.4);
        }

        /* === コネクトフォー専用スタイル === */
        .connect4-frame {
            background-color: var(--c4-board) !important;
            padding: 15px 15px 40px 15px !important; 
            border-radius: 10px 10px 4px 4px !important;
            box-shadow: 0 20px 0 var(--c4-board-shadow), 0 30px 50px rgba(0,0,0,0.5) !important;
            border: 2px solid #2c5e9e;
        }
        .connect4-board {
            gap: 10px !important; background-color: var(--c4-board);
            grid-template-columns: repeat(7, 50px);
        }
        .connect4-cell {
            background-color: var(--bg-color) !important; 
            border-radius: 50% !important;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.8) !important;
            overflow: visible !important; 
        }
        /* 落下アニメーション */
        @keyframes drop {
            0% { transform: translateY(-400px); opacity: 0; }
            60% { transform: translateY(20px); opacity: 1; }
            80% { transform: translateY(-10px); }
            100% { transform: translateY(0); }
        }
        .falling { animation: drop 0.5s cubic-bezier(0.25, 1, 0.5, 1) forwards; }

        /* === オセロ専用スタイル === */
        .othello-cell:hover { background-color: rgba(255,255,255,0.1); }
        @keyframes pop { 0% { transform: scale(0); } 90% { transform: scale(1.1); } 100% { transform: scale(1); } }
        .popping { animation: pop 0.3s ease-out; }

        /* 石の色定義 */
        .black { background: linear-gradient(45deg, #333, #000); }
        .white { background: linear-gradient(45deg, #fff, #ddd); }
        .red   { background: linear-gradient(45deg, #e74c3c, #c0392b); }
        .yellow{ background: linear-gradient(45deg, #f1c40f, #f39c12); }

        /* リセットボタン */
        #reset-btn {
            margin-top: 30px; padding: 10px 25px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            color: #ccc; border-radius: 30px; cursor: pointer; transition: all 0.2s;
        }
        #reset-btn:hover { background: rgba(255,255,255,0.2); color: #fff; transform: scale(1.05); }

        /* レスポンシブ対応 */
        @media (max-width: 500px) {
            .connect4-board { gap: 1vw !important; grid-template-columns: repeat(7, 12vw); }
            .cell { width: 12vw; height: 12vw; }
            .disc { width: 10vw; height: 10vw; }
        }
    </style>
</head>
<body>
    <h1 id="title">GAME ZONE</h1>
    
    <div id="menu-screen">
        <h2>Select a Game</h2>
        <button class="game-btn" onclick="startGame('othello')">OTHELLO</button>
        <button class="game-btn" style="filter: hue-rotate(40deg);" onclick="startGame('connect4')">CONNECT 4</button>
        <div class="waiting-text" id="menu-msg">Waiting for host...</div>
    </div>

    <div id="game-screen">
        <div id="status-card">
            <span id="turn-indicator"></span>
            <span id="status-text">...</span>
        </div>
        <div id="board-frame">
            <div id="board"></div>
        </div>
        <button id="reset-btn" onclick="resetToMenu()">EXIT GAME</button>
    </div>

    <script type="module">
        // 1. Playroomオブジェクトをesm形式でインポート
        import * as Playroom from "https://unpkg.com/playroomkit@latest/esm/multiplayer.js";

        // 2. インポートしたPlayroomの機能を使えるようにする
        const { insertCoin, isHost, setState, getState, myPlayer } = Playroom;

        let localState = { gameType: null, board: [], turn: 0 };

        insertCoin({ skipLobby: true }).then(() => {
            if (isHost()) setState("gameType", null);
        });

        function loop() {
            const gameType = getState("gameType");
            const turn = getState("turn");
            const board = getState("board");
            const winner = getState("winner");

            if (gameType !== localState.gameType) {
                localState.gameType = gameType;
                switchScreen(gameType);
            }

            if (gameType && board) {
                if (JSON.stringify(board) !== JSON.stringify(localState.board) || turn !== localState.turn || winner !== localState.winner) {
                    const diffIndex = findDiffIndex(localState.board, board);
                    localState.board = board;
                    localState.turn = turn;
                    localState.winner = winner;
                    drawBoard(gameType, board, diffIndex);
                    updateStatus(gameType, turn, winner);
                }
            }
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

        function switchScreen(type) {
            const menu = document.getElementById("menu-screen");
            const game = document.getElementById("game-screen");
            const frame = document.getElementById("board-frame");
            
            if (!type) {
                menu.style.display = "flex";
                game.style.display = "none";
                document.getElementById("menu-msg").innerText = isHost() ? "ゲームを選んでください" : "ホストがゲームを選択中...";
                document.querySelectorAll(".game-btn").forEach(b => b.disabled = !isHost());
            } else {
                menu.style.display = "none";
                game.style.display = "flex";
                frame.className = (type === 'connect4') ? 'connect4-frame' : ''; 
                document.getElementById("board").className = (type === 'connect4') ? 'connect4-board' : '';
            }
        }

        // 3. グローバル関数化 (onclickから呼び出すため)
        window.startGame = (type) => {
            if (!isHost()) return;
            let board, turn;
            
            if (type === 'othello') {
                board = Array(64).fill(0);
                board[27]=2; board[28]=1; board[35]=1; board[36]=2;
                turn = 1; 
            } else if (type === 'connect4') {
                board = Array(42).fill(0); 
                turn = 1;
            }
            
            setState("gameType", type);
            setState("board", board);
            setState("turn", turn);
            setState("winner", 0);
        }

        window.resetToMenu = () => {
            if (isHost()) setState("gameType", null);
        }

        function drawBoard(type, board, diffIndex) {
            const boardEl = document.getElementById("board");
            boardEl.innerHTML = "";
            
            if (type === 'othello') {
                boardEl.style.gridTemplateColumns = "repeat(8, 50px)";
            } else {
                boardEl.style.gridTemplateColumns = "repeat(7, 50px)";
            }

            board.forEach((cell, index) => {
                const div = document.createElement("div");
                div.className = "cell";
                if (type === 'connect4') div.classList.add('connect4-cell');
                else div.classList.add('othello-cell');
                
                div.onclick = () => handleClick(type, index);
                
                if (cell !== 0) {
                    const disc = document.createElement("div");
                    disc.className = "disc";
                    
                    if (type === 'othello') {
                        disc.classList.add(cell === 1 ? "black" : "white");
                        if (index === diffIndex) disc.classList.add('popping');
                    } else {
                        disc.classList.add(cell === 1 ? "red" : "yellow");
                        if (index === diffIndex) disc.classList.add('falling'); 
                    }
                    div.appendChild(disc);
                }
                boardEl.appendChild(div);
            });
        }

        function findDiffIndex(oldB, newB) {
            if (!oldB || oldB.length === 0) return -1;
            for(let i=0; i<newB.length; i++) {
                if (oldB[i] === 0 && newB[i] !== 0) return i;
            }
            return -1;
        }

        function handleClick(type, index) {
            const turn = getState("turn");
            const board = getState("board");
            const winner = getState("winner");
            
            // 観戦者・相手ターンチェック (簡易版)
            // Note: 厳密には myPlayer().id と seat ID のチェックが必要だが、今回は省略。
            // ターンが異なれば、クリックしても move が成功しないため、動作上は問題ない。
            if (winner !== 0) return;

            let newBoard = [...board];
            let success = false;

            if (type === 'othello') {
                success = playOthello(newBoard, index, turn);
            } else if (type === 'connect4') {
                success = playConnect4(newBoard, index, turn);
            }

            if (success) {
                setState("board", newBoard);
                const win = (type === 'othello') ? 0 : checkWinConnect4(newBoard, turn);
                if (win) {
                    setState("winner", turn);
                } else {
                    setState("turn", turn === 1 ? 2 : 1);
                }
            }
        }

        function playOthello(board, index, color) {
            if (board[index] !== 0) return false;
            const opponent = color === 1 ? 2 : 1;
            const directions = [-9,-8,-7,-1,1,7,8,9];
            let captured = false;
            
            for (let dir of directions) {
                let path = [];
                let curr = index + dir;
                while(curr >= 0 && curr < 64) {
                    const cx = curr % 8, px = (curr - dir) % 8;
                    const cy = Math.floor(curr/8), py = Math.floor((curr-dir)/8);
                    if(Math.abs(cx - px) > 1 || Math.abs(cy - py) > 1) break;

                    if (board[curr] === opponent) path.push(curr);
                    else if (board[curr] === color) {
                        if (path.length > 0) {
                            path.forEach(p => board[p] = color);
                            captured = true;
                        }
                        break;
                    } else break;
                    curr += dir;
                }
            }
            if (captured) board[index] = color;
            return captured;
        }

        function playConnect4(board, index, color) {
            const cols = 7; 
            const rows = 6;
            const col = index % cols; 
            
            for (let r = rows - 1; r >= 0; r--) {
                const targetIdx = r * cols + col;
                if (board[targetIdx] === 0) {
                    board[targetIdx] = color;
                    return true;
                }
            }
            return false; 
        }

        function checkWinConnect4(board, color) {
            const directions = [1, 7, 8, 6]; 
            const cols = 7; const rows = 6;

            for (let i = 0; i < 42; i++) {
                if (board[i] !== color) continue;

                for (let dir of directions) {
                    let count = 1;
                    for (let step = 1; step < 4; step++) {
                        let next = i + dir * step;
                        if (next < 0 || next >= 42) break;
                        
                        if (dir === 1 && Math.floor(i / cols) !== Math.floor(next / cols)) break;
                        
                        if (board[next] === color) count++;
                        else break;
                    }
                    if (count === 4) return true;
                }
            }
            return false;
        }

        function updateStatus(type, turn, winner) {
            const text = document.getElementById("status-text");
            const indicator = document.getElementById("turn-indicator");
            
            if (winner !== 0) {
                let winnerColor = winner === 1 ? (type==='othello'?"黒":"赤") : (type==='othello'?"白":"黄");
                text.innerText = `${winnerColor} の勝ち！`;
                indicator.style.backgroundColor = "transparent";
                return;
            }

            let colorName, colorCode;
            if (type === 'othello') {
                colorName = turn === 1 ? "黒" : "白";
                colorCode = turn === 1 ? "#000" : "#fff";
            } else {
                colorName = turn === 1 ? "赤" : "黄";
                colorCode = turn === 1 ? "#e74c3c" : "#f1c40f";
            }
            
            text.innerText = `${colorName} の番です`;
            indicator.style.backgroundColor = colorCode;
            indicator.style.boxShadow = (colorCode==="#fff") ? "0 0 10px #fff" : "none";
        }
    </script>
</body>
</html>
